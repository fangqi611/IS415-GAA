---
title: "In-Class Exercise 07: Geographic Segmentation with Spatially Constrained Cluster Analysis"
date: "March 3, 2024"
date-modified: "last-modified"
format: 
  html:
    fontsize: 18px
execute:
  echo: true
  eval: true
  freeze: true
  warning: false
  message: false
  fig_retine: 3
editor: visual
---

```{r}
pacman::p_load(rgdal, sp, spdep, tmap, sf, ClustGeo, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

```{r}
shan_sf <- st_read(dsn = "data/geospatial",
                   layer = "myanmar_township_boundaries") %>%
  filter (ST %in% c("Shan (East)", "Shan (North)",
                    "Shan (South)")) %>%
  select(c(2:7))
```

```{r}
shan_sf #or class(shan_sf)
```

Importing aspatial data into R environment

The csv file will be importing using *read_csv* function of readr package

```{r}
ict <- read_csv("data/aspatial/Shan-ICT.csv")
```

The imported InfoComm variables are extracted from The 2014 Myanmar Population and Housing Census Myanmar. The attribute data set is called ict. It is saved in Râ€™s \* tibble data.frame\* format.

```{r}
summary(ict)
#to quickly look for the range you want
```

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>% 
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>% #performing scaling on data until here
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) #useful to keep a tidy data
```

```{r}
summary(ict_derived)
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

```{r}
ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```

# EDA using choropleth map

```{r}
#| eval: false
shan_sf <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
  
write_rds(shan_sf, "data/rds/shan_sf.rds")
```

```{r}
shan_sf <- read_rds("data/rds/shan_sf.rds")
```

```{r}
qtm(shan_sf, "RADIO_PR")
```

# Correlation Analysis

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor, #calc correlation coeff
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

# Extracting clustering variables

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", 
         "COMPUTER_PR")

head(cluster_vars,10)
```

```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"
head(cluster_vars,10)
```

```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

# Computing proximity matrix

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

```{r}
proxmat
```

# Computing hierarchical clustering

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

```{r}
plot(hclust_ward, cex = 0.6) 
```
```{r}
shan_sp <- as_Spatial(shan_sf)
```

```{r}
shan.nb <- poly2nb(shan_sp)
summary(shan.nb)
```
```{r}
lcosts <- nbcosts(shan.nb, shan_ict)
```

```{r}
plot(st_geometry(shan_sf),
     border=gray(.5))

pts <- st_coordinates(st_centroid(shan_sf))

plot(shan.nb,
     pts,
     col = "blue",
     add=TRUE)

```
# Computing minimum spanning tree
```{r}
shan.w <- nb2listw(shan.nb, 
                   lcosts, 
                   style="B")
summary(shan.w)
```

```{r}
shan.mst <- mstree(shan.w)
```

```{r}
class(shan.mst)
```

```{r}
dim(shan.mst)
```

```{r}
head(shan.mst)
```

```{r}
plot(shan_sp, border=gray(.5))
```

```{r}
plot.mst(shan.mst,
         pts,
         col = "blue",
         cex.lab = 0.7,
         cex.circles = 0.05)
```

